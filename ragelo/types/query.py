from __future__ import annotations

from typing import Any

from ragelo.logger import logger
from ragelo.types.evaluables import AgentAnswer, Document, PairwiseGame
from ragelo.types.pydantic_models import BaseModel


class Query(BaseModel):
    """A user query that can have retrieved documents and agent answers.
    Args:
        qid str: The query ID.
        query str: The query text.
        metadata Optional[dict[str, Any]]: Metadata that can be templated in the prompt.
        retrieved_docs dict[str, Document]: A dictionary of retrieved documents, where the key is the document ID.
        answers list[AgentAnswer]: The list of agent answers.
        pairwise_games list[PairwiseGame]: The list games to be played between agent's answers. Generated by the evaluator.
    """

    qid: str
    query: str
    metadata: dict[str, Any] | None = None
    retrieved_docs: dict[str, Document] = {}
    answers: dict[str, AgentAnswer] = {}
    pairwise_games: list[PairwiseGame] = []

    def add_metadata(self, metadata: dict[str, Any] | None):
        """Adds metadata to the query that may be templated in the prompt.
        Args:
            metadata dict[str, Any]: The metadata to add to the query.
        """
        if not metadata:
            return
        if self.metadata is None:
            self.metadata = {}
        for k in metadata:
            if k in self.metadata:
                logger.warning(
                    f"Metadata {k} for query {self.qid} is being overwritten!\n"
                    f"Old metadata: {self.metadata[k]}\n"
                    f"New metadata: {metadata[k]}\n"
                )
            self.metadata[k] = metadata[k]

    def add_retrieved_docs(
        self,
        docs: list,
        agent: str | None = None,
        overwrite: bool = False,
    ):
        """Add a list of retrieved documents to the query.
        Args:
            docs list[Document | str] | list[Tuple[Document | str], float]: The list of documents (either the objects or the texts) to add to the query. Optionally, a score can be provided for each document.
            agent str: The agent that retrieved the documents.
        """
        # First, transform all of the strings into Document objects.
        # If an agent name was provided, but no score information exists,
        # assume the list is ranked and assign a score of 1/(n+1) to each document.
        for idx, doc in enumerate(docs):
            if isinstance(doc, tuple):
                doc, score = doc
                if agent is None:
                    raise ValueError(
                        "If you provide a score for each retrieved document, you should also provide an agent name."
                    )
            elif agent is not None:
                score = 1 / (idx + 1)
            else:
                score = None
            self.add_retrieved_doc(doc, score=score, agent=agent, overwrite=overwrite)

    def add_retrieved_doc(
        self,
        doc: Document | str,
        doc_id: str | None = None,
        score: float | None = None,
        agent: str | None = None,
        overwrite: bool = False,
    ):
        """Add a retrieved document to the query.
        Args:
            doc Document | str: The document (either the object or the text) to add to the query.
            doc_id str: The document ID. If not provided, it will be autogenerated.
            score float: The score of the document when retrieved.
            agent str: The agent that retrieved the document.
        """
        if doc_id is None:
            if isinstance(doc, Document):
                doc_id = doc.did
            else:
                doc_id = f"doc_{len(self.retrieved_docs) + 1}"
                logger.info(f"No doc_id provided. Using '{doc_id}' as doc_id")
        if isinstance(doc, str):
            doc = Document(did=doc_id, text=doc)
        doc = self.retrieved_docs.get(doc_id, doc.model_copy(deep=True))
        if agent is not None:
            doc.add_retrieved_by(agent, score, overwrite)
        if doc_id in self.retrieved_docs and not overwrite:
            logger.info(f"Query {self.qid} already have a document {doc_id} retrieved.")
            return

        self.retrieved_docs[doc_id] = doc

    def add_agent_answer(self, answer: AgentAnswer | str, agent: str | None = None):
        """Add an answer generated by an agent to the query.
        Args:
            answer AgentAnswer | str: The answer (either the object or the text) to add to the query.
            agent str: The id or name of the agent that generated the answer. If not provided, it will be autogenerated.
        """
        if agent is None:
            if isinstance(answer, AgentAnswer):
                agent = answer.agent
            else:
                agent = f"agent_{len(self.answers) + 1}"
                logger.info(f"No agent provided. Using '{agent}' as agent")
        if isinstance(answer, str):
            answer = AgentAnswer(agent=agent, text=answer)
        answer = self.answers.get(agent, answer)
        if answer.agent in self.answers:
            logger.warning(
                f"Answer from agent {answer.agent} already exists in query {self.qid}"
            )
            return
        self.answers[agent] = answer

    def get_qrels(
        self,
        relevance_key: str | None = "relevance",
        relevance_threshold: int = 0,
    ) -> dict[str, int]:
        """Get a qrels-formatted dictionary with the relevance of the retrieved documents.
        Args:
            relevance_key str: The key in the answer object that contains an integer with the relevance of the document.
            relevance_threshold int: The minimum relevance value to consider a document as relevant.
                Documents with a relevance lower than this value will be considered as 0.
        """
        qrels = {}
        if len(self.retrieved_docs) == 0:
            logger.warning(
                f"Query {self.qid} does not have any retrieved documents. Returning empty qrels."
            )
        docs_without_relevance = 0
        for did, document in self.retrieved_docs.items():
            if document.evaluation is None:
                docs_without_relevance += 1
                continue
            if isinstance(document.evaluation.answer, int):
                qrels[did] = document.evaluation.answer
            elif isinstance(document.evaluation.answer, str):
                try:
                    qrels[did] = int(document.evaluation.answer)
                except ValueError:
                    logger.warning(
                        f"Document {did} has a relevance key ({relevance_key})"
                        f" that cannot be converted to an int ({document.evaluation.answer})."
                        " Skipping."
                    )
                    continue
            elif isinstance(document.evaluation.answer, dict):
                if (
                    relevance_key is None
                    or relevance_key not in document.evaluation.answer
                ):
                    logger.warning(
                        f"Document {did} does not have a relevance key ({relevance_key})"
                        " in the evaluation. Skipping."
                    )
                    continue
                # check if the relevance is a number or a str that can be converted to an int
                if not isinstance(document.evaluation.answer[relevance_key], int):
                    try:
                        relevance = int(document.evaluation.answer[relevance_key])
                    except ValueError:
                        logger.warning(
                            f"Document {did} has a relevance key ({relevance_key})"
                            f" that cannot be converted to an int ({document.evaluation.answer[relevance_key]})."
                            " Skipping."
                        )
                        continue
                relevance = int(document.evaluation.answer[relevance_key])
                qrels[did] = 0 if relevance < relevance_threshold else relevance
        if docs_without_relevance > 0:
            logger.warning(
                f"Query {self.qid} has {docs_without_relevance} documents without relevance."
            )
        if docs_without_relevance == len(self.retrieved_docs):
            logger.error(f"Query {self.qid} has no documents without relevance.")
        return qrels

    def get_runs(
        self, agents: list[str] | None = None
    ) -> dict[str, dict[str, dict[str, float]]]:
        """Get a trec-style run dictionary with the documents retrieved by the agents provided.
        If no agents are provided, all agents will be included.
        Args:
            agents list[str]: The list of agent IDs to include in the run.
        """
        runs: dict[str, dict[str, dict[str, float]]] = {}
        for did, document in self.retrieved_docs.items():
            for agent, score in document.retrieved_by.items():
                if agents is not None and agent not in agents:
                    continue
                if agent not in runs:
                    runs[agent] = {self.qid: {}}
                runs[agent][self.qid][did] = float(score)

        if len(runs) == 0:
            logger.warning(
                f"Query {self.qid} does not have any retrieved documents with an agent assigned."
            )
        return runs
